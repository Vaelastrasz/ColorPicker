namespace colorPickerFeature {

  
  var ui_colorPopup;
  var ui_preview;
  var ui_paliter;



  function self.ready() {
    ui_preview = $(.previewColor);
    ui_paliter = $(.colorsPaliter);
    ui_colorPopup = $(.selectColorPopup); 
    stdout.println("PREVIEW ATTACHED");
  }

  class GeneralController {
    var colorBlocks = [];
    var _currentColor;
    property m_color(inputColor) {
      get {
        return _currentColor;
      } set {
        _currentColor = inputColor;
        ui_preview.style#background-color = _currentColor; //CHANGE IT TO EVENT
      }
    }

    function setCurrentColor(color) {
      m_color = color;
    }
  
    function updateUi() {
      if (removeAllBlocks()) {
        //add blocks from existing array
      } else {
        stdout.println("Removing color error occured!");
        return false;
      }
    }
    
    function addNewBlock(color, isAddToArray = true) {
      var sampleBlock = "<div class=\"colorBlock colorControl\" />";
      ui_paliter.append(sampleBlock);
      
      setCurrentColor(color);
      if (isAddToArray)
        colorBlocks.append(color);
    }
    
    function removeBlock(color) {} //is find by color seems OK? 
                                   //have to implement ID!

    function removeAllBlocks() {
      stdout.println("Start removing all");
      var i;
      for (i = 2; i < paliter.children.length; i++) {
        paliter.children[i].remove(); //check
      }

      stdout.println("End removing all! Children left: " + paliter.children);
      if (paliter.children.length === 2) 
        return true;
      return false;
    }

    function setBlockArray(colorArray) {
      colorBlocks = colorArray; //PostEvent to updateUI
      // colorBlocks.forEach(:colorElement: addNewBlock(colorElement, false));
    }
  }

  class ColorPicker: Element {
    this var editBtn;
    this var deleteBtn;

    function attached() {
      this.editBtn = $(.editColor);
      this.deleteBtn = $(.deleteColor);
      this.onClick = onClick;
      editBtn.onClick = editClick.bind(this);
      deleteBtn.onClick = deleteClick.bind(this);
    }
    
    function onClick() {
      ui_colorPopup.attributes["type"] = "edit";
      this.popup(ui_colorPopup, 2);
      GeneralController.setCurrentColor(this.style#background-color);
    }

    function editClick() {
      var editedColor = $(widget#color).value.toString();
      this.style#background-color = color(editedColor); //fix
      GeneralController.setCurrentColor(editedColor);
    }

    function deleteClick() {
      stdout.println(this);
      this.remove(); 
      GeneralController.setCurrentColor(ui_paliter.first.style#background-color);
    }

    function detached(){}
  }

  class ResetColor: Element {
    function attached() {
      this.onClick = onClick;
    }
    function onClick() {
      GeneralController.setCurrentColor("black");
    }
  }

  class SelectColor: Element {
    var addBtn;

    function attached() {
      this.onClick = onClick;
      addBtn = $(.addColor);
      addBtn.onClick = addClick;
    }

    function onClick() {
      ui_colorPopup.attributes["type"] = "add";
      $(.selectColor).popup(ui_colorPopup, 2);
    }

    function addClick() {
      stdout.println("ADD COLOR CLICK");
      var chosenColor = $(widget#color).value.toString();
      var sampleBlock = "<div class=\"colorBlock colorControl\" />";
      ui_paliter.append(sampleBlock);
      // colorBlocks.push(chosenColor);
      // GeneralController.addNewBlock(chosenColor);

      ui_paliter[ui_paliter.length - 1].style#background-color = color(chosenColor);
      GeneralController.setCurrentColor(chosenColor);
      
      ui_colorPopup.closePopup();

      stdout.println("ADD COLOR CLICK");
    }
  }

  class ColorsPaliter: Element {

    const maxElementWidth = 700;
    function attached() {
      stdout.println("ColorsPaliter Attached");
      view.on("size", function() {
        ui_paliter.attributes["type"]  = (ui_paliter.box(#width) < maxElementWidth ? "mesh" : "row");
      });
    }
  }
}